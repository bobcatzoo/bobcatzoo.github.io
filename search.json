[{"categories":["Stochastic-Calculus-for-Finance-II"],"content":"金融随机分析(Stochastic Calculus for Finance II Continuous-Time Models)第3章部分章节可视化笔记\n3.2 Scaled Random Walks 1 2 3 4  import numpy as np import pandas as pd import matplotlib.pyplot as plt import time  1  np.random.seed(1024)   3.2.1 Symmetric Random Walk \\[ X_j = 1 \\ \\ \\text{if} \\ \\omega_j = H , \\ \\ X_j = -1 \\ \\ \\text{if} \\ \\omega_j = T \\]\n\\[ M_0 = 0, \\ M_k = \\sum_{j=1}^{k} X_j, \\ \\text{for} \\ k = 1, 2, ... \\]\n1 2 3 4  t = 20 steps = np.append(np.arange(0, t, 1), t) random_walks = np.random.randint(0, 2, size=t) * 2 - 1 random_walks.shape  (20,)1 2  print(random_walks.mean()) print(random_walks.var())  0.4 0.83999999999999991 2  random_walks = np.append(np.array([0]),random_walks) random_walks = random_walks.cumsum()  1 2 3 4 5  def plot_random_walks(step, random_walk): plt.plot(step, random_walk) plt.xlabel(\"Time\", fontsize=14) plt.ylabel(\"Location\", fontsize=14) plt.grid()  1 2  plt.figure(figsize=(8, 6)) plot_random_walks(steps, random_walks)    ​\n3.2.5 Scaled Symmetric Random Walk 将对称随机游动缩小$n$倍，并保证$nt$为正整数，则有\n\\[ W ^ {(n)} (t) = \\frac{1}{\\sqrt{n}} M_{nt} \\]\n1  nstep = 100  1  steps = np.append(np.arange(0, t, 1/nstep), t)  1  steps.shape  (2001,)1 2 3  random_walks = 1 / np.sqrt(nstep) * (np.random.randint(0, 2, size=nstep*t) * 2 - 1) random_walks = np.append(np.array([0]),random_walks) random_walks = random_walks.cumsum()  1  random_walks.shape  (2001,)1 2  plt.figure(figsize=(8, 6)) plot_random_walks(steps, random_walks)   \n1 2  nwalks = 10 random_walks = 1 / np.sqrt(nstep) * (np.random.randint(0, 2, size=(nwalks, nstep*t)) * 2 - 1)  1 2  random_walks = np.append(np.zeros((nwalks, 1)),random_walks, axis=1) random_walks = random_walks.cumsum(axis=1)  1  random_walks.shape  (10, 2001)1 2 3 4  plt.figure(figsize=(8, 6)) for i in range(len(random_walks)): plot_random_walks(steps, random_walks[i]) plt.grid()   \n3.2.6 Limiting Distribution of the Scaled Random Walk 1 2 3 4 5 6 7 8  nstep = 1000 steps = np.append(np.arange(0, t, 1/nstep), t) nwalks = 10000 random_walks = 1 / np.sqrt(nstep) * (np.random.randint(0, 2, size=(nwalks, nstep*t)) * 2 - 1) random_walks = np.append(np.zeros((nwalks, 1)),random_walks, axis=1) random_walks = random_walks.cumsum(axis=1) random_walks.shape  (10000, 20001)1  random_walks_final = random_walks[:, nstep*t]  1 2 3 4 5 6  plt.figure(figsize=(8, 6)) plt.hist(random_walks_final, bins=20) plt.axvline(random_walks_final.mean(), color='r') plt.xlabel(\"Final location\", fontsize=14) plt.ylabel(\"Counts\", fontsize=14) plt.grid()   \n1 2  print(random_walks_final.mean()) print(random_walks_final.var())  -0.0257725629303726 20.436329775000004 3.2.7 Log-Normal Distribution as the Limit of the Binomial Model 首先，我们考虑下Theorem 3.2.2提及的$r = 0$时特殊情形 假设估价上升因子为$u_n = 1 + \\frac{\\sigma}{\\sqrt{n}}$，上升概率为$\\tilde{p} = \\frac{1 + r - d_n}{u_n - d_n} = \\frac{\\frac{\\sigma}{\\sqrt{n}}}{2 \\frac{\\sigma}{\\sqrt{n}}} = \\frac{1}{2}$，下降因子为$d_n = 1 - \\frac{\\sigma}{\\sqrt{n}}$，下降概率为$\\tilde{q} = \\frac{u_n - 1 - r}{u_n - d_n} = \\frac{\\frac{\\sigma}{\\sqrt{n}}}{2 \\frac{\\sigma}{\\sqrt{n}}} = \\frac{1}{2}$。\n可求得\n\\[ nt = H_{nt} + T_{nt} \\]\n\\[ M_{nt} = H_{nt} - T_{nt} \\]\n\\[ H_{nt} = \\frac{1}{2} (nt + M_{nt}) \\]\n\\[ T_{nt} = \\frac{1}{2} (nt - M_{nt}) \\]\n股价$S_{n} (t)$可以表示为$S(0)$为起点，上升$H_{nt}$次和下降$T_{nt}$次以后的金额即：\n\\[ S_n(t) = S(0) u_n ^ {H_{nt}} d_n ^ {T_{nt}} = S(0) \\ \\left( 1 + \\frac{\\sigma}{\\sqrt{n}} \\right) ^ {\\frac{1}{2} (nt + M_{nt})} \\left( 1 - \\frac{\\sigma}{\\sqrt{n}} \\right) ^ {\\frac{1}{2} (nt - M_{nt})} \\]\n根据Theorem 3.2.2，当$n \\to \\infty$时:\n\\[ \\lim_{n \\to \\infty} S_n(t) = S_0 \\exp \\left( \\sigma W(t) - \\frac{1}{2} \\sigma ^2 t \\right) \\]\n1 2 3 4 5 6 7 8 9 10 11  nstep = 100 t = 10 nwalks = 10 r = 0 sigma = 0.05 S_0 = 100 u_n = 1 + sigma/np.sqrt(nstep) d_n = 1 - sigma/np.sqrt(nstep) p = 0.5 q = 0.5  1  steps = np.append(np.arange(0, t, 1/nstep), t)  1 2 3  X_nt = np.random.randint(0, 2, size=(nwalks,nstep*t)) * 2 - 1 M_nt = np.append(np.zeros((nwalks, 1)), X_nt, axis=1) M_nt = M_nt.cumsum(axis=1)  1  M_nt.shape  (10, 1001)1 2  H_nt = 0.5 * (nstep*t + M_nt) T_nt = 0.5 * (nstep*t - M_nt)  1  S_t = S_0 * pow(u_n, H_nt) * pow(d_n, T_nt)  1 2 3 4 5  plt.figure(figsize=(8, 6)) for i in range(nwalks): plot_random_walks(steps, S_t[i]) plt.plot(steps, S_t.mean(axis=0), color='r') plt.grid()   \n $\\sigma$的定义如下，注意此$\\sigma$非随机游走模拟终值分布的$\\sigma$\n \\[ \\frac{1}{T_2 - T_1} \\lim_{j=0}^{n-1} \\left( \\log \\frac{S(t_{j+1})}{S(t_j)} \\right) ^2 \\ \\approx \\ \\sigma ^ 2 \\]\n 以下我们随机选择一条路径进行计算验证\n 1 2 3 4 5 6 7 8 9  i = np.random.randint(nwalks) walks = S_t[i] walks_list = list(walks) walks_list_ = [walks_list[i+1]/walks_list[i] for i in range(len(walks_list)-1)] walks = np.array(walks_list_) walks = np.log(walks) walks = walks * walks sigma = np.sqrt(np.sum(walks) / t) sigma  0.0500004166729163  $\\sigma$的金额与我们前面设定的金额一致。\n 1 2 3 4 5 6 7 8 9  from numpy import random nwalks = 10000 random_walks = random.choice([u_n, d_n], p=[p, q], size=(nwalks, nstep*t)) random_walks = np.append(np.ones((nwalks, 1)),random_walks, axis=1) random_walks_cumprod = random_walks.cumprod(1) paths = random_walks_cumprod[:, nstep*t] paths = paths * S_0  1 2 3 4 5 6 7  bins = 20 plt.figure(figsize=(8, 6)) plt.hist(paths, bins = bins) plt.axvline(paths.mean(), color='r') plt.xlabel(\"Final location\", fontsize=14) plt.ylabel(\"Counts\", fontsize=14) plt.grid()   \n几何布朗运动及其均值与方差（详细推导见以下3.8节）:\n\\[ S_t = S_0 \\exp \\left( \\sigma W(t) + (r - \\frac{\\sigma^2}{2})t\\right) \\tag{1.31} \\]\n\\[ \\mathbb{E} (S_t) = S_0 e ^ {r t} \\]\n\\[ \\mathbb{Var}(S_t) = S_0 ^ 2 e ^ {2 r t} \\left( e ^ {\\sigma ^ 2 t} - 1\\right) \\]\n1 2 3 4 5 6 7 8 9 10 11  sample_mean = paths.mean() theoretical_mean = S_0 * np.exp(r*t) sample_std = paths.std() theoretical_std = np.sqrt(S_0 * S_0 * np.exp(2*r*t) * (np.exp(sigma * sigma * t) - 1)) print(\"sample_mean = %f\" % sample_mean) print(\"theoretical_mean = %f\" % theoretical_mean) print(\"sample_std = %f\" % sample_std) print(\"theoretical_std = %f\" % theoretical_std)  sample_mean = 99.950854 theoretical_mean = 100.000000 sample_std = 15.860752 theoretical_std = 15.910860 将终值金额取对数，绘制其直方图并比较其均值和方差与理论值的一致性。\n1 2 3 4 5 6 7 8  log_paths = np.log(paths) plt.figure(figsize=(8, 6)) plt.hist(log_paths, bins = bins) plt.axvline(log_paths.mean(), color='r') plt.xlabel(\"Final location\", fontsize=14) plt.ylabel(\"Counts\", fontsize=14) plt.grid()   \n1 2 3 4 5 6 7 8 9 10 11  sample_mean = log_paths.mean() theoretical_mean = np.log(S_0) + (r - 0.5 * sigma * sigma) * t sample_var = log_paths.var() theoretical_var = sigma * sigma * t print(\"sample_mean = %f\" % sample_mean) print(\"theoretical_mean = %f\" % theoretical_mean) print(\"sample_var = %f\" % sample_var) print(\"theoretical_var = %f\" % theoretical_var)  sample_mean = 4.592218 theoretical_mean = 4.592670 sample_var = 0.024949 theoretical_var = 0.025000 通过计算可知，模拟结果的均值及方差与理论值较为吻合。\n其次，我们考虑Exercise 3.8涉及的一般情形 我们用$n$期二叉树模型模拟单位时间间隔内的股价变化，单位时间内的利率为$r_n = \\frac{r}{n}$，假设上升因子为$u_n = e ^ {\\frac{\\sigma}{\\sqrt{n}}}$，下降因子为$d_n = e ^ {-\\frac{\\sigma}{\\sqrt{n}}}$。则\n\\[ \\tilde{p}_n = \\frac{1+r_n-d_n}{u_n-d_n} = \\frac{1+\\frac{r}{n} - e ^ {-\\sigma/ \\sqrt{n}}} {e ^ {\\sigma/ \\sqrt{n}} - e ^ {-\\sigma/ \\sqrt{n}}} \\tag{1.21} \\]\n\\[ \\tilde{q}_n = \\frac{u_n-1-r_n}{u_n-d_n} = \\frac{e ^ {\\sigma/ \\sqrt{n}} -1 -\\frac{r}{n}} {e ^ {\\sigma/ \\sqrt{n}} - e ^ {-\\sigma/ \\sqrt{n}}} \\tag{1.22} \\]\n选取$t = t_1 - t_0$，满足$nt$为整数，我们用$nt$期二叉树模拟$t$时间内的股价。定义\n\\[ M_{nt,n} = \\sum_{k=1}^{nt} X_{k,n} \\tag{1.23} \\]\n其中$X_{1,n}, X_{2,n} ... X_{n,n}$为独立同分布随机变量，满足\n\\[ \\widetilde{\\mathbb{P}}(X_{k,n} = 1) = \\tilde{p}_n,\\ \\ \\widetilde{\\mathbb{P}}(X_{k,n} = -1) = \\tilde{q}_n, \\ k = 1,2,...n. \\]\n记$nt$次二叉树模拟内出现股价上升的次数为$H_{nt}$，出现下降的次数为$T_{nt}$，则$nt = H_{nt} + T_{nt}$，$M_{nt,n} = H_{nt} - T_{nt}$。由此可得：\n\\[ H_{nt} = \\frac{1}{2}(nt + M_{nt,n}) \\]\n\\[ T_{nt} = \\frac{1}{2}(nt - M_{nt,n}) \\]\n$t$时刻股价经过$nt$期二叉树模拟后可由下式得出\n\\[ \\begin{aligned} S_n(t) \u0026= S_0 u_{n}^{H_{nt,n}} d_{n}^{T_{nt,n}} \\\\ \\\\ \u0026= S_0 u_{n}^{\\frac{1}{2}(nt + M_{nt,n})} d_{n}^{\\frac{1}{2}(nt - M_{nt,n})} \\\\ \\\\ \u0026= S_0 \\exp \\left(\\frac{\\sigma}{2\\sqrt{n}}(nt + M_{nt,n})\\right) \\exp \\left(-\\frac{\\sigma}{2\\sqrt{n}}(nt - M_{nt,n})\\right) \\\\ \\\\ \u0026= S_0 \\exp \\left(\\frac{\\sigma}{\\sqrt{n}}M_{nt,n} \\right) \\end{aligned} \\tag{1.24} \\]\n如果我们能求得$n \\to \\infty$时$\\frac{\\sigma}{\\sqrt{n}}M_{nt,n}$的分布$\\chi$，则股价$S(t)$的分布也就随之可以确定。根据习题提示，我们分4步进行证明。\n\\[ \\blacksquare \\Box \\square \\square \\]\n1. 根据矩生成函数与概率分布的一一对应关系，我们可以考虑求解$\\frac{1}{\\sqrt{n}}M_{nt,n}$的矩生成函数$\\varphi_n(u)$，然后再求其极限。 \\[ \\begin{aligned} \\varphi_n(u) \u0026= \\widetilde{\\mathbb{E}} \\left( e ^ {u \\frac{1}{\\sqrt{n}}M_{nt,n}} \\right) \\\\ \\\\ \u0026= \\left[ \\widetilde{\\mathbb{E}} \\left( e ^ {u \\frac{1}{\\sqrt{n}}X_{1,n}} \\right) \\right] ^{nt} \\\\ \\\\ \u0026= \\left( e^{\\frac{u}{\\sqrt{n}} \\tilde{p}_n} + e^{-\\frac{u}{\\sqrt{n}} \\tilde{q}_n} \\right) ^{nt} \\\\ \\\\ \u0026= \\left[ e^{\\frac{u}{\\sqrt{n}}} \\left(\\frac{1+\\frac{r}{n} - e ^ {-\\sigma/ \\sqrt{n}}} {e ^ {\\sigma/ \\sqrt{n}} - e ^ {-\\sigma/ \\sqrt{n}}}\\right) + e^{-\\frac{u}{\\sqrt{n}}} \\left(\\frac{e ^ {\\sigma/ \\sqrt{n}}-1-\\frac{r}{n}} {e ^ {\\sigma/ \\sqrt{n}} - e ^ {-\\sigma/ \\sqrt{n}}}\\right)\\right] ^{nt} \\end{aligned} \\tag{1.25} \\]\n2. 上式关于离散变量$n$的极限转换为关于连续变量$x$的极限。 选取$x = \\frac{1}{\\sqrt{n}}$，则\n\\[ \\lim_{n \\to \\infty}\\varphi_n(u) = \\lim_{x \\to 0}\\varphi_{\\frac{1}{x^2}}(u) \\]\n\\[ \\lim_{x \\to 0} \\varphi_{\\frac{1}{x^2}}(u) = \\left[ e^{ux} \\left(\\frac{1+rx^2 - e ^ {-\\sigma x}} {e ^ {\\sigma x} - e ^ {-\\sigma x}}\\right) + e^{-ux} \\left(\\frac{e ^ {\\sigma x}-1-rx^2} {e ^ {\\sigma x} - e ^ {-\\sigma x}}\\right)\\right] ^{\\frac{t}{x^2}} \\tag{1.26} \\]\n3. 由于指数函数不易求极限，我们转而求其对数函数$\\log \\left[ \\varphi_{\\frac{1}{x^2}}(u) \\right]$ 通过观察分母的形式，我们考虑构造双曲函数，然后利用双曲函数的以下性质：\n\\[ \\text{sinh}z = \\frac{e^z - e^{-z}}{2} \\]\n\\[ \\text{cosh}z = \\frac{e^z + e^{-z}}{2} \\]\n\\[ \\text{sinh}(A-B) = \\text{sinh}A \\text{cosh}B - \\text{cosh}A\\text{sinh}B \\]\n对公式(1.26)进行化简如下：\n\\[ \\begin{aligned} \\lim_{x \\to 0} \\log \\left[\\varphi_{\\frac{1}{x^2}}(u)\\right] \u0026= \\lim_{x \\to 0} \\frac{t}{x^2} \\log \\left[ e^{ux} \\left(\\frac{1+rx^2 - e ^ {-\\sigma x}} {e ^ {\\sigma x} - e ^ {-\\sigma x}}\\right) + e^{-ux} \\left(\\frac{e ^ {\\sigma x}-1-rx^2} {e ^ {\\sigma x} - e ^ {-\\sigma x}}\\right)\\right] \\\\ \\\\ \u0026= \\lim_{x \\to 0} \\frac{t}{x^2} \\log \\left[ \\frac{(1+rx^2)e^{ux} + e^{(u-\\sigma)x}} {e^{\\sigma x} - e^{-\\sigma x}} + \\frac{e^{(\\sigma-u)x} - (1+rx^2)e^{-ux}} {e^{\\sigma x} - e^{-\\sigma x}} \\right] \\\\ \\\\ \u0026= \\lim_{x \\to 0} \\frac{t}{x^2} \\log \\left[ \\frac{(1+rx^2) (e^{ux}-e^{-ux}) + e^{(\\sigma-u)x} - e^{-(\\sigma-u)x}} {e^{\\sigma x} - e^{-\\sigma x}} \\right] \\\\ \\\\ \u0026= \\lim_{x \\to 0} \\frac{t}{x^2} \\log \\left[ \\frac{(1+rx^2) \\cdot 2 \\cdot \\text{sinh}ux + 2 \\cdot \\text{sinh}(\\sigma-u)x} {2 \\cdot \\text{sinh}\\sigma x} \\right] \\\\ \\\\ \u0026= \\lim_{x \\to 0} \\frac{t}{x^2} \\log \\left[ \\frac{(1+rx^2) \\text{sinh}ux + \\text{sinh}(\\sigma-u)x} {\\text{sinh}\\sigma x}\\right] \\\\ \\\\ \u0026= \\lim_{x \\to 0} \\frac{t}{x^2} \\log \\left[ \\frac{(1+rx^2)\\text{sinh}ux + \\text{sinh}\\sigma x \\cdot \\text{cosh}ux -\\text{cosh}\\sigma x \\cdot \\text{sinh}ux} {\\text{sinh}\\sigma x} \\right] \\\\ \\\\ \u0026= \\lim_{x \\to 0} \\frac{t}{x^2} \\log \\left[ \\text{cosh}ux + \\frac{(1+rx^2-\\text{cosh}\\sigma x) \\text{sinh}ux} {\\text{sinh}\\sigma x}\\right] \\end{aligned} \\tag{1.27} \\]\n然后利用以下双曲函数的泰勒级数展开式:\n\\[ \\text{sinh} z = z + O(z^3) \\]\n\\[ \\text{cosh} = 1 + \\frac{z^2}{2} + O(z^4) \\]\n对公式(1.27)继续化简:\n\\[ \\begin{aligned} \\lim_{x \\to 0} \\log \\left[\\varphi_{\\frac{1}{x^2}}(u)\\right] \u0026= \\lim_{x \\to 0} \\frac{t}{x^2} \\log \\left[ \\text{cosh}ux + \\frac{(1+rx^2-\\text{cosh}\\sigma x) \\text{sinh}ux} {\\text{sinh}\\sigma x}\\right] \\\\ \\\\ \u0026= \\lim_{x \\to 0} \\frac{t}{x^2} \\log \\left[ 1 + \\frac{(ux)^2}{2} + O(x^4) + \\frac{[ 1+rx^2 - 1 - \\frac{(\\sigma x)^2}{2} + O(x^4) ]\\cdot[ux+O(x^3)]} {\\sigma x + O(x^3)} \\right] \\\\ \\\\ \u0026= \\lim_{x \\to 0} \\frac{t}{x^2} \\log \\left[ 1 + \\frac{u^2x^2}{2} + \\frac{(r-\\frac{\\sigma ^2}{2})ux^3 + O(x^5)} {\\sigma x + O(x^3)} + O(x^4) \\right] \\\\ \\\\ \u0026= \\lim_{x \\to 0} \\frac{t}{x^2} \\log \\left[ 1 + \\frac{u^2x^2}{2} + \\frac{(r-\\frac{\\sigma ^2}{2})ux^3 (1+O(x^2))} {\\sigma x(1 + O(x^2))} + O(x^4) \\right] \\\\ \\\\ \u0026= \\lim_{x \\to 0} \\frac{t}{x^2} \\log \\left[ 1 + \\frac{u^2x^2}{2} + \\frac{rux^2}{\\sigma} - \\frac{\\sigma ux^2}{2}+ O(x^4) \\right] \\end{aligned} \\tag{1.28} \\]\n4. 利用 $\\text{log}(1+x) = x + O(x^2)$ 进一步化简上式 \\[ \\begin{aligned} \\lim_{x \\to 0} \\log \\left[\\varphi_{\\frac{1}{x^2}}(u) \\right]\u0026= \\lim_{x \\to 0} \\frac{t}{x^2} \\left[ \\frac{u^2x^2}{2} + \\frac{rux^2}{\\sigma} - \\frac{\\sigma ux^2}{2}+ O(x^4) \\right] \\\\ \\\\ \u0026= t \\left( \\frac{u^2}{2} + \\frac{ru}{\\sigma} - \\frac{\\sigma u}{2}\\right) \\\\ \\\\ \u0026= \\frac{t}{2}u^2 + t \\left( \\frac{r}{\\sigma}-\\frac{\\sigma}{2} \\right)u \\end{aligned} \\tag{1.29} \\]\n由公式(1.29)可得当$n \\to \\infty$时,\n\\[ \\varphi_n(u) \\to \\exp \\left( \\frac{t}{2}u^2 + t ( \\frac{r}{\\sigma}-\\frac{\\sigma}{2} )u \\right) \\]\n\\[ \\Box \\square \\square \\blacksquare \\]\n我们知道正态随机变量$X$的矩生成函数为\n\\[ \\varphi_X(u) = \\exp \\left( \\frac{\\sigma^2}{2}u^2 + \\mu u \\right) \\tag{1.30} \\]\n其中$\\mu$为均值，$\\sigma$为标准差。由此，我们可以得出当$n \\to \\infty$时，$\\frac{1}{\\sqrt{n}}M_{nt,n}$趋近于均值为$(\\frac{r}{\\sigma}-\\frac{\\sigma}{2})t$，标准差为$\\sqrt{t}$的正态分布。亦即$\\frac{\\sigma}{\\sqrt{n}}M_{nt,n}$趋近于均值为$(r-\\frac{\\sigma^2}{2})t$，标准差为$\\sigma \\sqrt{t}$的正态分布。而这正与分布$\\sigma W(t) + (r - \\frac{\\sigma^2}{2})t,\\ W(t)$为布朗运动相吻合，因此我们可以将$\\lim_{n \\to \\infty} S_n(t) = S_t$写成如下形式\n\\[ S_t = S_0 \\exp \\left( \\sigma W(t) + (r - \\frac{\\sigma^2}{2})t\\right) \\tag{1.31} \\]\n下面我们继续求$dS_t$即股价变动的表达式，令\n\\[ X_t = \\sigma W(t) + (r - \\frac{\\sigma^2}{2})t \\]\n\\[ f(X_t) = S_t= S_0 e^{X_t} \\]\n则\n\\[ {f}'(X_t) = {f}''(X_t) = f(X_t) \\]\n\\[ d X_t = \\sigma d W(t) + (r - \\frac{\\sigma^2}{2}) d t \\]\n\\[ d X_t d X_t = \\sigma^2 d t \\]\n根据伊藤公式可得:\n\\[ \\begin{aligned} d S_t \u0026= {f}'(X_t) d X_t + \\frac{1}{2} {f}''(X_t) d X_t d X_t \\\\ \\\\ \u0026= S_t d X_t + \\frac{1}{2} S_t d X_t d X_t \\\\ \\\\ \u0026= \\sigma S_t d W(t) + r S_t dt - \\frac{\\sigma^2}{2}S_t dt + \\frac{\\sigma^2}{2}S_t dt\\\\ \\\\ \u0026= \\sigma S_t d W(t) + r S_t dt \\end{aligned} \\tag{1.32} \\]\n这样，我们就通过公式(1.31)求得了公式(1.32)，反之，我们也可以由公式(1.32)求得公式(1.31)，即二者互相等价。\n1 2 3 4 5 6  nstep = 1000 npaths = 10000 r = 0.03 sigma = 0.2 S_0 = 100 t = 8  1 2 3 4 5  r_n = r / nstep u_n = np.exp(sigma / np.sqrt(nstep)) d_n = np.exp(-sigma / np.sqrt(nstep)) p_n = (1 + r_n - d_n) / (u_n - d_n) q_n = (u_n - 1 - r_n) / (u_n - d_n)  1 2 3 4 5  print(\"r_n = %f\" % r_n) print(\"u_n = %f\" % u_n) print(\"d_n = %f\" % d_n) print(\"p_n = %f\" % p_n) print(\"q_n = %f\" % q_n)  r_n = 0.000030 u_n = 1.006345 d_n = 0.993695 p_n = 0.500791 q_n = 0.4992091 2  from collections import Counter #用于计算array中数值出现次数 import time  1 2 3 4 5 6 7 8  simples = 10000000 risk_neutral_probability = random.choice([u_n, d_n], p=[p_n, q_n], size=(simples)) simple_pn = Counter(risk_neutral_probability)[u_n] / simples simple_qn = Counter(risk_neutral_probability)[d_n] /simples print(\"simple_pn = %f\" % simple_pn) print(\"simple_qn = %f\" % simple_qn)  simple_pn = 0.500771 simple_qn = 0.499229 步数足够大时，样本概率分布趋近于理论计算的风险中性概率\n1 2 3 4 5 6 7 8 9 10 11 12  start = time.time() steps = np.append(np.arange(0, t, 1/nstep), t) rnp = random.choice([u_n, d_n], p=[p_n, q_n], size=(npaths, nstep*t)) rnp = np.append(np.ones((npaths, 1)), rnp, axis=1) rnp_cumpd = rnp.cumprod(1) paths = rnp_cumpd[:, nstep*t] paths = paths * S_0 end = time.time() print(end-start)  1.72950983047485351  paths.shape  (10000,)1  print(paths.mean())  125.576200604717941 2 3 4 5 6  plt.figure(figsize=(8, 6)) plt.hist(paths, bins = bins) plt.axvline(paths.mean(), color='r') plt.xlabel(\"Final location\", fontsize=14) plt.ylabel(\"Counts\", fontsize=14) plt.grid()   \n1 2 3 4 5 6 7 8 9 10 11  sample_mean = paths.mean() theoretical_mean = S_0 * np.exp(r*t) sample_std = paths.std() theoretical_std = np.sqrt(S_0 * S_0 * np.exp(2*r*t) * (np.exp(sigma * sigma * t) - 1)) print(\"sample_mean = %f\" % sample_mean) print(\"theoretical_mean = %f\" % theoretical_mean) print(\"sample_std = %f\" % sample_std) print(\"theoretical_std = %f\" % theoretical_std)  sample_mean = 125.576201 theoretical_mean = 127.124915 sample_std = 75.941466 theoretical_std = 78.0683371 2 3 4 5 6 7 8  log_paths = np.log(paths) plt.figure(figsize=(8, 6)) plt.hist(log_paths, bins = bins) plt.axvline(log_paths.mean(), color='r') plt.xlabel(\"Final location\", fontsize=14) plt.ylabel(\"Counts\", fontsize=14) plt.grid()   \n1 2 3 4 5 6 7 8 9 10 11  sample_mean = log_paths.mean() theoretical_mean = np.log(S_0) + (r - 0.5 * sigma * sigma) * t sample_var = log_paths.var() theoretical_var = sigma * sigma * t print(\"sample_mean = %f\" % sample_mean) print(\"theoretical_mean = %f\" % theoretical_mean) print(\"sample_var = %f\" % sample_var) print(\"theoretical_var = %f\" % theoretical_var)  sample_mean = 4.677318 theoretical_mean = 4.685170 sample_var = 0.311049 theoretical_var = 0.320000 通过计算可知，在$r \\neq 0$的一般情况下，模拟结果的均值及方差与理论值较为吻合。\n3.7 Reflection Principle 3.7.1 理论结果 定理3.7.1 对于所有$m \\neq 0$，随机变量$\\tau_m$具有累积分布函数：\n\\[ \\begin{aligned} \\mathbb{P}(\\tau_m \\leq t ) \u0026= 2 \\mathbb{P}(W(t) = m) \\\\ \\\\ \u0026= \\frac{2}{\\sqrt{2 \\pi t}} \\int_{m}^{\\infty} e^{-\\frac{x^2}{2t}} dx \\\\ \\\\ \u0026= \\int_{\\frac{\\left| m \\right|}{\\sqrt{t}}}^{\\infty} e^{-\\frac{y^2}{2}} dy = 2 \\left[ 1 - \\Phi(\\frac{\\left| m \\right|}{\\sqrt{t}}) \\right], \\qquad t \\geq 0 \\end{aligned} \\]\n以及概率密度：\n\\[ f_{\\tau_m} = \\frac{d}{dt} \\mathbb{P}(\\tau_m \\leq t) = \\frac{\\left| m \\right|}{t\\sqrt{2\\pi t}} e^{-\\frac{m^2}{2t}}, \\quad t \\geq 0 \\]\n 其中$\\tau_m$表示布朗运动首次到达水平$m$的时间\n 3.7.2 Python模拟 1. 生成布朗运动路径  如以下生成的(npath * nstep)维矩阵超出内存，可用2.6小节循环方法解决\n 1 2 3 4 5 6 7  npaths = 10000 nstep = 10000 t = 3 steps = np.append(np.arange(0, t, 1/nstep), t) paths = random.normal(loc=0, scale=np.sqrt(1/nstep), size=(npaths, nstep*t)) paths = np.append(np.zeros((npaths, 1)), paths, axis=1) paths = paths.cumsum(1)    通过不断修改npath和nstep的值，可以发现nstep的值对最终结果即模拟的$\\mathbb{P}(\\tau_m \\leq t )$值更具影响力，也就是说nstep越大，则每条路径的波动次数越多，每次波动幅度也越小，越符合布朗运动的特性。\n 2. 检验终值分布的均值、标准差及直方图 1 2 3 4 5  mean = paths[:,nstep*t].mean() var = paths[:,nstep*t].var() print(\"sample_mean = %f\" % mean) print(\"sample_var = %f\" % var)  sample_mean = 0.002820 sample_var = 2.9796381 2 3  plt.hist(paths[:,nstep*t], bins=20) plt.axvline(mean, color='r') plt.grid()   \n3. 求 $\\tau_{m} \\leq t$ 的概率，即在时间 $t$ 内路径达到或超过m的条数 1 2 3  m = 2 actual_prob = np.sum(paths.max(axis=1) \u003e= m) / npaths actual_prob  0.2485 4. $\\tau_{m} \\leq t$ 的理论概率 1 2 3 4  import scipy.stats as st theoretical_prob = 2 * (1-st.norm.cdf(m/np.sqrt(t), 0, 1)) theoretical_prob  0.24821307898992373  实际值与理论值的差异百分率\n 1  np.abs(actual_prob - theoretical_prob) / theoretical_prob * 100  0.11559463797953867 5. 循环方法  如以上步骤1中生成的[npath, nstep*t]维矩阵超出内存，可用以下循环形式解决\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  npaths = 10000 nstep = 10000 path_max = [] for i in range(npaths): paths_ = random.normal(loc=0, scale=np.sqrt(1/nstep), size=(nstep*t)) paths_ = paths_.cumsum() path_max.append(paths_.max()) path_max = np.array(path_max) actual_prob = np.sum(path_max \u003e= m) / npaths print(actual_prob) print(theoretical_prob) print(np.abs(actual_prob - theoretical_prob) / theoretical_prob * 100)  0.2489 0.24821307898992373 0.2767465005758886 6. 对称性 1 2  actual_prob = np.sum(paths.min(axis=1) \u003c= -m) / npaths actual_prob  0.2522 3.7.3 小规模示例 1 2 3 4 5 6 7 8  npaths = 10 nstep = 100 t = 5 steps = np.append(np.arange(0, t, 1/nstep), t) paths = random.normal(loc=0, scale=np.sqrt(1/nstep), size=(npaths, nstep*t)) paths = np.append(np.zeros((npaths, 1)), paths, axis=1) paths = paths.cumsum(1)  1 2 3 4 5  mean = paths[:,nstep*t].mean() var = paths[:,nstep*t].var() print(\"sample_mean = %f\" % mean) print(\"sample_var = %f\" % var)  sample_mean = 0.077913 sample_var = 2.8155121 2 3 4 5 6  for i in range(npaths): plt.plot(steps, paths[i]) plt.plot(steps, paths.mean(axis=0), color = 'b') plt.axhline(2, color='r') plt.axhline(-2, color='r') plt.grid()   ​\n ​\n1 2 3  m = 2 actual_prob = np.sum(paths.max(axis=1) \u003e= m) / npaths actual_prob  0.31 2  theoretical_prob = 2 * (1-st.norm.cdf(m/np.sqrt(t), 0, 1)) theoretical_prob  0.371093369522697451 2  actual_prob = np.sum(paths.min(axis=1) \u003c= -m) / npaths actual_prob  0.3 3.8 番外 3.8.1 对数正态分布 在概率论与统计学中，任意随机变量的对数服从正态分布，则这个随机变量服从的分布称为对数正态分布。即如果$Y$是正态分布的随机变量，则$\\exp(Y)$为对数正态分布；同样，如果$X$是对数正态分布，则$\\ln(X)$为正态分布。如果一个变量可以看做是许多很小独立因子的乘积，则这个变量可以看做是对数正态分布。一个典型的例子是股票投资的长期收益率，他可以看作是每天收益率的乘积。\n对于$Y \\sim N(\\mu, \\sigma)$，$X = e ^ Y$，对数正态分布$X$的概率密度函数为\n\\[ f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi} x \\sigma} e ^ {-\\frac{(\\ln x - \\mu) ^ 2}{2 \\sigma ^ 2}} \\ \\ \\text{for} \\ \\sigma \\geq 0 \\ \\text{and} \\ -\\infty \\leq \\mu \\leq \\infty . \\]\n其值域为$x \\in [0, +\\infty)$\n其期望值及方差分别为\n\\[ \\mathbb{E}(X) = e ^ {\\mu + \\sigma ^ 2 / 2} \\]\n\\[ \\mathbb{Var}(X) = (e ^ {\\sigma ^ 2} - 1) e ^ {2 \\mu + \\sigma ^ 2} \\]\n3.8.2 几何布朗运动 由上面3.2.7节我们知道估价过程服从几何布朗运动，即\n\\[ S_t = S_0 \\exp \\left( \\sigma W(t) + (r - \\frac{\\sigma^2}{2})t\\right) \\tag{1.31} \\]\n将上式做对数变换后即得\n\\[ \\ln \\left( \\frac{S_t}{S_0} \\right) = \\sigma W(t) + (r - \\frac{\\sigma^2}{2})t \\]\n$Y = \\ln \\left( \\frac{S_t}{S_0} \\right)$服从正态分布，且$Y \\sim N \\left( (r - \\frac{\\sigma^2}{2})t, \\ \\sigma \\sqrt{t} \\right)$ 即$\\hat{\\mu} = (r - \\frac{\\sigma^2}{2})t$， $\\hat{\\sigma} = \\sigma \\sqrt{t}$\n将$\\hat{\\mu}$和$\\hat{\\sigma}$分别带入对数正态分布的期望和方差公式，即得\n\\[ \\mathbb{E}(e ^ Y) = e ^ {\\hat{\\mu} + \\hat{\\sigma} ^ 2 / 2} \\]\n\\[ \\mathbb{Var}(e ^ Y) = (e ^ {\\hat{\\sigma} ^ 2} - 1) e ^ {2 \\hat{\\mu} + \\hat{\\sigma} ^ 2} \\]\n进一步整理后即可得到：\n\\[ \\mathbb{E} (S_t) = S_0 e ^ {r t} \\]\n\\[ \\mathbb{Var}(S_t) = S_0 ^ 2 e ^ {2 r t} \\left( e ^ {\\sigma ^ 2 t} - 1\\right) \\]\n全文完$\\blacksquare$\n致谢：\n妈咪叔LaTeX助力 在线LaTeX\n参考:\nStochastic Calculus for Finance II - Continuous-Time Models\n维基百科\n","description":"","tags":["Finance"],"title":"Chapter 03 Brownian Motion部分章节可视化","uri":"/posts/scff-chapter-03-brownian-motion/"},{"categories":["欧式期权定价"],"content":"2008年的1次考证经历，第1次知道了期权并学到了期权定价的Black-Scholes-Merton公式，被其深深迷住，断断续续翻阅了许多书籍及文献资料，包括Hull那本及基础的数学分析、实分析及基于测度论的概率论等等，但由于大学专业和数学不相关，看起来很吃力，虽有收获但感觉却与​Black-Scholes-Merton公式渐行渐远，需要补习的基础知识太多。直到工作后于2015年左右开始读世图影印出版的Stochastic Calculus for Finance II方才有种醍醐灌顶的感觉，似懂非懂中看到第5章开头后就因种种原因放弃了。\n时间一直来到了2021年，趁COVID-19疫情期间工作之余，不忘初心又重新拾起那段记忆，从头开始又来到了第5章，过往的疑惑及不解在此刻正逐步消散。\n在此结合Stochastic Calculus for Finance II前5章的学习，对风险中性测度下的Black-Scholes-Merton理论推导做个总结，并结合C++和Python实现其定价公式，以便对给定的参数，计算出期权价格。希望若干年以后还能不忘初心，照着笔记顺藤摸瓜🍉\n1. 风险中性测度下的股价过程 1.1 概率测度$\\mathbb{P}$下的股价过程 假设 $W(t), 0 \\leq t \\leq T $是概率空间$(\\Omega, \\mathcal{F}, \\mathbb{P})$上的布朗运动，$\\mathcal{F}(t), 0\\leq t \\leq T$是该布朗运动的域流，考虑股价$S(t)$，其微分如下：\n\\[ d S(t)=\\alpha(t) S(t) d t+\\sigma(t) S(t) d W(t), \\quad 0 \\leq t \\leq T. \\tag{1.1} \\]\n其中平均回报率$\\alpha(t)$和股价波动率$\\sigma(t)$为适应性过程，则$S(t)$满足以下等式：\n\\[ S(t)=S(0) \\exp \\left\\{\\int_{0}^{t} \\sigma(s) d W(s)+\\int_{0}^{t}\\left[\\alpha(s)-\\frac{1}{2} \\sigma^{2}(s)\\right] d s\\right\\} \\tag{1.2} \\]\n假设我们有适应性利率过程$R(t)$，定义折现过程\n\\[ D(t)=e^{-\\int_{0}^{t} R(s) d s} \\tag{1.3} \\]\n则\n\\[ d D(t)=-R(t) D(t) d t \\tag{1.4} \\]\n$D(t)S(t)$及其微分$d (D(t)S(t))$分别为：\n\\[ D(t) S(t)=S(0) \\exp \\left\\{\\int_{0}^{t} \\sigma(s) d W(s)+\\int_{0}^{t}\\left[\\alpha(s)-R(s)-\\frac{1}{2} \\sigma^{2}(s)\\right] d s\\right\\} \\tag{1.5} \\]\n\\[ \\begin{aligned} d(D(t) S(t)) \u0026=[\\alpha(t)-R(t)] D(t) S(t) d t+\\sigma(t) D(t) S(t) d W(t) \\\\ \\\\ \u0026=\\sigma(t) D(t) S(t)[\\Theta(t) d t+d W(t)] \\end{aligned} \\tag{1.6} \\]\n其中定义风险的市场价格$\\Theta(t)=\\frac{\\alpha(t)-R(t)}{\\sigma(t)} $。\n1.2 Girsanov Theorem 假设$W(t), 0 \u003c t \u003c T$是概率空间$(\\Omega, \\mathcal{F}, \\mathbb{P})$上的布朗运动，$\\mathcal{F}(t)$为该布朗运动的域流，$\\Theta(t), 0 \u003c t \u003c T$为适应性过程。我们定义\n\\[ Z(t) =\\exp \\left\\{-\\int_{0}^{t} \\Theta(u) d W(u)-\\frac{1}{2} \\int_{0}^{t} \\Theta^{2}(u) d u\\right\\} \\tag{1.7} \\]\n\\[ \\widetilde{W}(t) =W(t)+\\int_{0}^{t} \\Theta(u) d u \\tag{1.8} \\]\n并假设\n\\[ \\mathbb{E} \\int_{0}^{T} \\Theta^{2}(u) Z^{2}(u) d u让$Z = Z(T)$。那么$\\mathbb{E}Z = 1$且在由\n\\[ \\widetilde{\\mathbb{P}}(A) = \\int_{A}Z(\\omega) d \\mathbb{P}(\\omega) \\quad \\text{对所有} A \\in \\mathcal{F}. \\tag{1.10} \\]\n定义的概率测度$\\widetilde{\\mathbb{P}}$下，$\\widetilde{W}(t), 0 \u003c t \u003c T$是布朗运动。$\\Box$\n1.3 概率测度$\\widetilde{\\mathbb{P}}$下的股价过程 根据Girsanov Theorem，在概率测度$\\widetilde{\\mathbb{P}}$下，$d \\widetilde W(t) = \\Theta(t) d t+d W(t) $，因此公式$(1.6)$也可以写为\n\\[ d (D(t)S(t)) = \\sigma(t) D(t) S(t) d \\widetilde W(t) \\tag{1.11} \\]\n两边同时积分\n\\[ D(t) S(t)=S(0)+\\int_{0}^{t} \\sigma(u) D(u) S(u) d \\widetilde{W}(u) \\tag{1.12} \\]\n由于在概率测度$\\widetilde{\\mathbb{P}}$下，$\\int_{0}^{t} \\sigma(u) D(u) S(u) d \\widetilde{W}(u)$是伊藤过程，因此是一个鞅。\n因此我们称Girsanov Theorem下的概率测度$\\widetilde{\\mathbb{P}}$为风险中性测度(risk-neutral measure)。\n将$d \\widetilde W(t) = \\Theta(t) d t+d W(t) $带入公式$(1.1)$，可以得到在概率测度$\\widetilde{\\mathbb{P}}$下，公式$(1.1)$和$(1.2)$分别可以改写成公式$(1.13)$和公式$(1.14)$的形式\n\\[ d S(t)= R(t) S(t) d t+\\sigma(t) S(t) d \\widetilde {W}(t) \\tag{1.13} \\]\n\\[ S(t) = S(0) \\exp \\left\\{\\int_{0}^{t} \\sigma(s) d \\widetilde{W}(s)+\\int_{0}^{t}\\left[R(s)-\\frac{1}{2} \\sigma^{2}(s)\\right] d s\\right\\} \\tag{1.14} \\]\n2. 风险中性测度下投资组合的价值过程 假设投资者初始资本为$X(0)$，在任意时间$t, 0 \u003c t \u003c T $持有$\\Delta(t)$份股票，同时以利率$R(t)$投资或借贷于货币市场，以维持自融资状态，则投资组合价值的微分为\n\\[ \\begin{aligned} d X(t) \u0026=\\Delta(t) d S(t)+R(t) \\left[ X(t)-\\Delta(t) S(t) \\right] d t \\\\ \\\\ \u0026=\\Delta(t) [\\alpha(t) S(t) d t+\\sigma(t) S(t) d W(t)]+R(t)[X(t)-\\Delta(t) S(t)] d t \\\\ \\\\ \u0026=R(t) X(t) d t+\\Delta(t)[\\alpha(t)-R(t)] S(t) d t+\\Delta(t) \\sigma(t) S(t) d W(t) \\\\ \\\\ \u0026=R(t) X(t) d t+\\Delta(t) \\sigma(t) S(t)[\\Theta(t) d t+d W(t)] \\end{aligned} \\tag{2.1} \\]\n根据$\\text{Ito}$乘法法则，由公式$(1.4)$和$(1.6)$可得\n\\[ \\begin{aligned} d(D(t) X(t)) \u0026=\\Delta(t) \\sigma(t) D(t) S(t)[\\Theta(t) d t+d W(t)] \\\\ \\\\ \u0026=\\Delta(t) d(D(t) S(t)) \\\\ \\\\ \u0026=\\Delta(t) \\sigma(t) D(t) S(t) d \\widetilde W(t) \\end{aligned} \\tag{2.2} \\]\n由此投资者有两种选择：\n 以利率$R(t)$投资于货币市场；\n 在风险中性测度$\\widetilde{\\mathbb{P}}$下投资于平均回报率为$R(t)$的股票。\n  但由于在风险中性测度$\\widetilde{\\mathbb{P}}$下，投资组合的折现价值$D(t)X(t)$是鞅，因此不管投资者如何选择，其投资组合的平均回报率均为为$R(t)$。\n3. 风险中性测度下的期权定价 我们令$\\mathcal{F}(T)$可测的随机变量$V(T)$表示在时刻$T$衍生证券空头的潜在支付(payoff) $(S(T)-K)^+$，投资者为了对冲看涨期权空头即未来所面临的潜在支出$V(T)$，那么其持有的投资组合$X(t)$需要使以下等式几乎必然成立(almost surely)\n\\[ X(T) = V(T) \\tag{3.1} \\]\n我们先假设公式$(3.1)$成立，并由此确定初始资本$X(0)$和$\\Delta t$过程。由$D(t)X(t)$在测度$\\widetilde{\\mathbb{P}}$是鞅的事实我们有\n\\[ D(t) X(t)=\\widetilde{\\mathbb{E}}[D(T) X(T) \\mid \\mathcal{F}(t)]=\\widetilde{\\mathbb{E}}[D(T) V(T) \\mid \\mathcal{F}(t)] \\tag{3.2} \\]\n$X(t)$表示在时刻$t$为完全对冲衍生证券支付$V(T)$所持有的投资组合价值，我们将其称之为衍生证券在时刻 $t$ 的价格并用$V(t)$表示，那么公式$(3.2)$可以写成\n\\[ D(t) V(t)=\\widetilde{\\mathbb{E}}[D(T) V(T) \\mid \\mathcal{F}(t)], 0 \\leq t \\leq T \\tag{3.3} \\]\n由于$D(t)$是$\\mathcal{F}(t)$可测的，因此我们可以将其移到公式右侧，得到\n\\[ V(t)=\\widetilde{\\mathbb{E}}\\left[e^{-\\int_{t}^{T} R(u) d u} V(T) \\mid \\mathcal{F}(t)\\right], 0 \\leq t \\leq T \\tag{3.4} \\]\n我们将公式$(3.3)$和$(3.4)$成为连续时间下风险中性定价公式(risk-neutral pricing formula)。\n4. 推导$\\text{Black-Scholes-Merton}$公式 为简单起见，我们假设$\\sigma(t)$和$R(t)$分别为常数 $\\sigma$ 和 $r$，则公式$(3.4)$简化为\n\\[ \\widetilde{\\mathbb{E}}\\left[e^{-r(T-t)}(S(T)-K)^{+} \\mid \\mathcal{F}(t)\\right] \\tag{4.1} \\]\n公式$(4.1)$仅依赖于时刻$t$和股价$S(t)$，由于几何布朗运动是马尔可夫过程，因此存在$c(t, S(t))$满足\n\\[ c(t, S(t)) = \\widetilde{\\mathbb{E}}\\left[e^{-r(T-t)}(S(T)-K)^{+} \\mid \\mathcal{F}(t)\\right] \\tag{4.2} \\]\n公式$(1.10)$简化为\n\\[ S(t) = S(0) \\exp \\left\\{\\sigma \\widetilde{W}(t)+\\left(r-\\frac{1}{2} \\sigma^{2}\\right) t\\right\\} \\tag{4.3} \\]\n则$S(T)$等于\n\\[ \\begin{aligned} S(T) \u0026=S(t) \\exp \\left\\{\\sigma(\\widetilde{W}(T)-\\widetilde{W}(t))+\\left(r-\\frac{1}{2} \\sigma^{2}\\right) \\tau\\right\\} \\\\ \\\\ \u0026=S(t) \\exp \\left\\{-\\sigma \\sqrt{\\tau} Y+\\left(r-\\frac{1}{2} \\sigma^{2}\\right) \\tau\\right\\} \\end{aligned} \\tag{4.4} \\]\n其中$\\tau = T - t$，$Y$是标准正态随机变量\n\\[ Y = - \\frac{\\widetilde{W}(T) - \\widetilde{W}(t)} {\\sqrt{T-t}} \\tag{4.5} \\]\n公式$(4.2)$可以写成如下形式\n\\[ \\begin{aligned} c(t, x) \u0026= \\widetilde{\\mathbb{E}}\\left[e^{-r \\tau}\\left(x \\exp \\left\\{-\\sigma \\sqrt{\\tau} Y+\\left(r-\\frac{1}{2} \\sigma^{2}\\right) \\tau\\right\\}-K\\right)^{+}\\right] \\\\ \\\\ \u0026= \\frac{1}{\\sqrt{2 \\pi}} \\int_{-\\infty}^{\\infty} e^{-r \\tau}\\left[ x \\exp \\left\\{-\\sigma \\sqrt{\\tau} y+\\left(r-\\frac{1}{2} \\sigma^{2}\\right) \\tau\\right\\}-K\\right]^{+} e^{-\\frac{1}{2} y^{2}} d y \\end{aligned} \\tag{4.6} \\]\n其中被积函数\n\\[ \\left[ x \\exp \\left\\{-\\sigma \\sqrt{\\tau} y+\\left(r-\\frac{1}{2} \\sigma^{2}\\right) \\tau\\right\\}-K\\right]^{+} \\tag{4.7} \\]\n为正，当且仅当\n\\[ y 由此\n\\[ \\begin{aligned} c(t, x) \u0026=\\frac{1}{\\sqrt{2 \\pi}} \\int_{-\\infty}^{d_{-}(\\tau, x)} e^{-r \\tau}\\left(x \\exp \\left\\{-\\sigma \\sqrt{\\tau} y+\\left(r-\\frac{1}{2} \\sigma^{2}\\right) \\tau\\right\\}-K\\right) e^{-\\frac{1}{2} y^{2}} d y \\\\ \\\\ \u0026=\\frac{1}{\\sqrt{2 \\pi}} \\int_{-\\infty}^{d_{-}(\\tau, x)} x \\exp \\left\\{-\\frac{y^{2}}{2}-\\sigma \\sqrt{\\tau} y-\\frac{\\sigma^{2} \\tau}{2}\\right\\} d y \\\\ \\\\ \u0026- \\frac{1}{\\sqrt{2 \\pi}} \\int_{-\\infty}^{d_{-}(\\tau, x)} e^{-r \\tau} K e^{-\\frac{1}{2} y^{2}} d y \\\\ \\\\ \u0026=\\frac{x}{\\sqrt{2 \\pi}} \\int_{-\\infty}^{d_{-}(\\tau, x)} \\exp \\left\\{-\\frac{1}{2}(y+\\sigma \\sqrt{\\tau})^{2}\\right\\} d y-e^{-r \\tau} K N\\left(d_{-}(\\tau, x)\\right) \\\\ \\\\ \u0026=\\frac{x}{\\sqrt{2 \\pi}} \\int_{-\\infty}^{d_{-}(\\tau, x)+\\sigma \\sqrt{\\tau}} \\exp \\left\\{-\\frac{z^{2}}{2}\\right\\} d z-e^{-r \\tau} K N\\left(d_{-}(\\tau, x)\\right) \\\\ \\\\ \u0026=x N\\left(d_{+}(\\tau, x)\\right)-e^{-r \\tau} K N\\left(d_{-}(\\tau, x)\\right) \\end{aligned} \\tag{4.9} \\]\n其中\n\\[ d_+(\\tau, x) = d_-(\\tau, x) + \\sigma \\sqrt{\\tau} = d_{-}(\\tau, x)=\\frac{1}{\\sigma \\sqrt{\\tau}}\\left[\\log \\frac{x}{K}+\\left(r+\\frac{1}{2} \\sigma^{2}\\right) \\tau\\right] \\tag{4.10} \\]\n由此我们得到了欧式看涨期权定价公式\n\\[ \\text{BSM}(\\tau, x, K, r, \\sigma) = x N\\left(d_{+}(\\tau, x)\\right)-e^{-r \\tau} K N\\left(d_{-}(\\tau, x)\\right) \\tag{4.11} \\]\n5. 欧式期权定价公式 根据上述对$\\text{Black-Scholes-Merton}$期权定价公式的推导，对于当前股价为$S_0$，行权价格为$K$，行权期为$T$，无风险利率为常数$r$，股价波动率为常数$\\sigma$的看涨期权，其期权费$c(S_0, K, T, r, \\sigma)$为：\n\\[ c(S_0, K, T, r, \\sigma)=N\\left(d_{1}\\right) S_{0}-N\\left(d_{2}\\right) K \\exp (-r T) \\tag{5.1} \\]\n其中\n\\[ d_{1} = \\frac{1}{\\sigma \\sqrt{T}}\\left(\\log \\left(\\frac{S_0}{K}\\right)+\\left(r+\\frac{\\sigma^{2}}{2}\\right) \\sqrt{T}\\right) \\tag{5.2} \\]\n\\[ d_{2} = \\frac{1}{\\sigma \\sqrt{T}}\\left(\\log \\left(\\frac{S_0}{K}\\right)+\\left(r-\\frac{\\sigma^{2}}{2}\\right) \\sqrt{T}\\right) \\tag{5.3} \\]\n$N(x)$为标准正态分布累积分布函数：\n\\[ N(x) = \\frac{1}{\\sqrt{2 \\pi}} \\int_{-\\infty}^{x} \\exp \\left(-\\frac{t^{2}}{2}\\right) d t \\tag{5.4} \\]\n对应看跌期权费$p(S_0, K, T, r, \\sigma)$为:\n\\[ p(S_0, K, T, r, \\sigma)=N\\left(-d_{2}\\right) K \\exp (-r T)-N\\left(-d_{1}\\right) S_0 \\tag{5.5} \\]\n6. 期权定价的C++实现 6.1 实现$N(x)$函数 - From Scratch to Boost Library 定价公式$(1)$-$(5)$中涉及$N(x)$、$\\exp(x)$和$\\log(x)$等3个函数，其中$\\exp(x)$和$\\log(x)$已在标准库\u003ccmath\u003e中实现，可以直接使用。因此只剩$N(x)$需要我们在标准库外自己实现或寻求其他库的支持。我们按照如下三种方式分别进行实现：\n 多项式逼近法 数值积分法 调用Boost库  6.1.1 多项式逼近法 如$x \u003e 0$，定义$k = 1/(1 + 0.2316419x)$，则$N(x)$可用如下关于$k$多项式进行逼近 \\( \\small 1 − \\frac{1}{\\sqrt{2 \\pi}} \\exp(-\\frac{x^2} {2}) k(0.319381530 + k(−0.356563782 + k(1.781477937 + k(−1.821255978 + 1.330274429k)))) \\tag{6.1} \\)\n借助$N(x) + N(-x) = 1$可以求得$N(-x)$即$x \u003c 0$时$N(x)$的值。\nC++实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  const double Pi = 3.141592653589793; const double root2Pi = sqrt(2.0 * Pi); double normcdf_poly(double x) { if (x \u003c 0) return 1 - normcdf_ploy(-x); double k = 1 / (1 + 0.2316419 * x); double poly = k * (0.319381530 + k * (-0.356563782 + k * (1.781477937 + k * (-1.821255978 + 1.330274429 * k)))); double approx = 1.0 - 1.0 / root2Pi * exp(-0.5 * x * x) * poly; return approx; }   6.1.2 数值积分法 对于实数域上$\\mathbb R \\to \\mathbb R$的黎曼积分\n\\[ F(b) - F(a) = \\int_{a}^{b} f(x) d x \\tag{6.2} \\]\n令$\\Delta x = \\frac{(b-a)}{N}$，根据黎曼积分定义，我们可以用以下矩形的面积和逼近$\\int_{a}^{b} f(x) d x$：\n\\[ \\lim_{N \\to \\infty} \\sum_{i=0}^{N-1} f\\left(a+(i+\\frac{1}{2}) \\Delta x\\right) \\Delta x \\tag{6.3} \\]\n只要$N$取值足够大即可很好的逼近积分值，可以通过定义$f(x) = x ^ 2 + 1$进行简单验证，C++实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  #include \u003ciostream\u003e#include \u003ccmath\u003eusing namespace std; double f_x(double x) { return pow(x, 2) + 1; } double integrate_fx(double a, double b, int N) { double delta = (b - a) / N; double integrate = 0.0; int i = 0; while (i \u003c N) { double x = a + (i + 0.5) * delta; integrate += f_x(x) * delta; i++; } return integrate; } int main() { double a = 1; double b = 3; int N = 1000; double integrate_ = 0.0; integrate_ = integrate_fx(a, b, N); cout \u003c\u003c integrate_ \u003c\u003c endl; //返回10+2/3(约等于10.666667)  return 0; }   下面我们考虑如何用数值积分法逼近\n\\[ N(x)=\\frac{1}{\\sqrt{2 \\pi}} \\int_{-\\infty}^{x} \\exp \\left(-\\frac{t^{2}}{2}\\right) d t \\]\n由于积分下限为$- \\infty$，我们需要考虑进行变量替换，定义$t = x + 1 - \\frac{1} {s}$，则$N(x)$等价于如下积分：\n\\[ \\frac{1} {\\sqrt {2 \\pi}} \\int_{0}^{1} \\frac{1}{s^{2}} \\exp \\left(-\\frac{\\left(x+1-\\frac{1}{s}\\right)^{2}}{2}\\right) \\mathrm{d} s \\tag{6.4} \\]\nC++实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  double normcdf_integrate(double x) { int a = 0; int b = 1; double N = 1000; double delta = 1 / N; double integrate = 0.0; for (int i = 0; i \u003c N; i++) { double s = a + (i + 0.5) * delta; double t = x + 1 - pow(s, -1); double f = pow(2 * PI, -0.5) * pow(s, -2) * exp(-0.5 * t * t); integrate += f * delta; } return integrate; }   6.1.3 调用boost库 我们可以通过如下方式调用boost库中的累积分布函数（Cumulative Distribution Function，简称$\\mathrm{cdf}$)的实现\n1 2 3 4 5 6 7 8 9 10 11  #include \"boost\\math\\distributions\\normal.hpp\"#include \u003crandom\u003e double normcdf_boost(double x) { double cdf = 0.0; boost::math::normal_distribution\u003c\u003e norm(0, 1); //生成标准正态分布 \tcdf = boost::math::cdf(norm, x); //计算N(x)值 \treturn cdf; }   6.2 期权费计算的C++实现 实现$N(x)$后，计算公式$(1)$中欧式看涨期权$c(S_0, K, T, r, \\sigma)$的障碍就清除了。下面我们分别定义blackScholesCallPrice和blackScholesPutPrice函数完成计算$c(S_0, K, T, r, \\sigma)$和$p(S_0, K, T, r, \\sigma)$。\n1 2 3 4 5 6 7 8 9 10 11  double blackScholesCallPrice(double K, double T, double S_t, double vol, double r) { double d1 = pow((vol * sqrt(T)), -1) * (log(S_t / K) + (r + 0.5 * pow(vol, 2)) * sqrt(T)); double d2 = d1 - vol * sqrt(T); //以下normcdf(x)函数3选1，默认选normcdf_poly(x)，使用normcdf_boost(x)时请自行配置boost库  double callPrice = normcdf_poly(d1) * S_t - normcdf_poly(d2) * K * exp(-r * T); //double callPrice = normcdf_integrate(d1) * S_t - normcdf_integrate(d2) * K * exp(-r * T);  //double callPrice = normcdf_boost(d1) * S_t - normcdf_boost(d2) * K * exp(-r * T);  return callPrice; }  1 2 3 4 5 6 7 8 9 10 11  double blackScholesPutPrice(double K, double T, double S_t, double vol, double r) { double d1 = pow((vol * sqrt(T)), -1) * (log(S_t / K) + (r + 0.5 * vol * vol) * sqrt(T)); double d2 = d1 - vol * sqrt(T); //以下normcdf(x)函数3选1，默认选normcdf_poly(x)，使用normcdf_boost(x)时请自行配置boost库  double putPrice = normcdf_poly(-d2) * K * exp(-r * T) - normcdf_poly(-d1) * S_t; //double putPrice = normcdf_integrate(-d2) * K * exp(-r * T) - normcdf_integrate(-d1) * S_t;  //double putPrice = normcdf_boost(-d2) * K * exp(-r * T) - normcdf_boost(-d1) * S_t;  return putPrice; }   6.3 完整工程文件及测试 头文件stdafx.h\n1 2 3 4 5 6  #pragma once #include \u003ciostream\u003e#include \u003ccmath\u003e//请在Visual Studio中自行配置好boost库后取消注释 //#include \"boost\\math\\distributions\\normal.hpp\" //#include \u003crandom\u003e    头文件OptionPricing.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #pragma once  static const double PI = 3.14159265358979; //定义Pi值  //S_t: spotPrice //T: maturity //K: strikePrice //vol: volatility //r: riskFreeInterestRate  //声明看涨期权定价公式 double blackScholesCallPrice(double K, double T, double S_t, double vol, double r); //声明看跌期权定价公式 double blackScholesPutPrice(double K, double T, double S_t, double vol, double r);   源文件OptionPricing.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  #include \"OptionPricing.h\"#include \"stdafx.h\" static const double root2Pi = sqrt(2.0 * PI); static inline double normcdf_poly(double x) { if (x \u003c 0) return 1 - normcdf_poly(-x); double k = 1 / (1 + 0.2316419 * x); double poly = k * (0.319381530 + k * (-0.356563782 + k * (1.781477937 + k * (-1.821255978 + 1.330274429 * k)))); double approx = 1.0 - 1.0 / root2Pi * exp(-0.5 * x * x) * poly; return approx; } static inline double normcdf_integrate(double x) { int a = 0; int b = 1; double N = 1000; double delta = 1 / N; double integrate = 0.0; for (int i = 0; i \u003c N; i++) { double s = a + (i + 0.5) * delta; double t = x + 1 - pow(s, -1); double f = pow(2 * PI, -0.5) * pow(s, -2) * exp(-0.5 * t * t); integrate += f * delta; } return integrate; } //请在Visual Studio中自行配置好boost库后取消注释 /* static inline double normcdf_boost(double x) { double cdf = 0.0; boost::math::normal_distribution\u003c\u003e norm(0, 1); //生成标准正态分布 cdf = boost::math::cdf(norm, x); //计算N(x)值 return cdf; } */ //S_t: spotPrice //T: maturity //K: strikePrice //vol: volatility //r: riskFreeInterestRate  double blackScholesCallPrice(double K, double T, double S_t, double vol, double r) { double d1 = pow((vol * sqrt(T)), -1) * (log(S_t / K) + (r + 0.5 * pow(vol, 2)) * sqrt(T)); double d2 = d1 - vol * sqrt(T); //以下normcdf(x)函数3选1，默认选normcdf_poly(x)，使用normcdf_boost(x)时请自行配置boost库  double callPrice = normcdf_poly(d1) * S_t - normcdf_poly(d2) * K * exp(-r * T); //double callPrice = normcdf_integrate(d1) * S_t - normcdf_integrate(d2) * K * exp(-r * T);  //double callPrice = normcdf_boost(d1) * S_t - normcdf_boost(d2) * K * exp(-r * T);  return callPrice; } double blackScholesPutPrice(double K, double T, double S_t, double vol, double r) { double d1 = pow((vol * sqrt(T)), -1) * (log(S_t / K) + (r + 0.5 * vol * vol) * sqrt(T)); double d2 = d1 - vol * sqrt(T); //以下normcdf(x)函数3选1，默认选normcdf_poly(x)，使用normcdf_boost(x)时请自行配置boost库  double putPrice = normcdf_poly(-d2) * K * exp(-r * T) - normcdf_poly(-d1) * S_t; //double putPrice = normcdf_integrate(-d2) * K * exp(-r * T) - normcdf_integrate(-d1) * S_t;  //double putPrice = normcdf_boost(-d2) * K * exp(-r * T) - normcdf_boost(-d1) * S_t;  return putPrice; }   测试文件main.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  #include \u003ciostream\u003e#include \"OptionPricing.h\"using namespace std; int main() { double K = 100.0; double S_t = 110.0; double vol = 0.1; double r = 0.03; double T = 0.5; double call; double put; double putCallParity; call = blackScholesCallPrice(K, T, S_t, vol, r); cout \u003c\u003c \"The call option price is: \" \u003c\u003c call \u003c\u003c endl; //11.6725  put = blackScholesPutPrice(K, T, S_t, vol, r); cout \u003c\u003c \"The put option price is: \" \u003c\u003c put \u003c\u003c endl; //0.183688  cout \u003c\u003c endl; cout \u003c\u003c \"\u003cPut-Call-Parity = Call Price - Put Price\u003e Testing\" \u003c\u003c endl; cout \u003c\u003c \"\u003cCall Price - Put Price\u003e is: \" \u003c\u003c call - put \u003c\u003c endl; putCallParity = S_t - exp(-r * T) * K; cout \u003c\u003c \"\u003cPut-Call-Parity\u003e is: \" \u003c\u003c putCallParity \u003c\u003c endl; cout \u003c\u003c \"Wonderful! It's correct.\" \u003c\u003c endl; return 0; }   其中看涨-看跌期权平价公式为\n\\[ S_0 - \\exp(-rT)K = c(S_0, K, T, r, \\sigma) - p(S_0, K, T, r, \\sigma) \\tag{6.5} \\]\n7. 期权定价的Python实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  import math import numpy as np from scipy.stats import norm //定义以下简写变量 //K: strikePrice //T: maturity //S_t: spotPrice //vol: volatility //r: riskFreeRate //定义d1和d2 def d1f(K, T, S_t, vol, r) : return math.pow(vol * np.sqrt(T), -1) * \\ (np.log(S_t / K) + (r + 0.5 * math.pow(vol, 2) * np.sqrt(T))) def d2f(K, T, S_t, vol, r) : return d1f(K, T, S_t, vol, r) - vol * np.sqrt(T) //定义看涨-看跌期权计算公式 def blackScholesCallPrice(K, T, S_t, vol, r) : d1 = d1f(K, T, S_t, vol, r) d2 = d2f(K, T, S_t, vol, r) callPrice = norm.cdf(d1) * S_t - norm.cdf(d2) * K * np.exp(-r * T) return callPrice def blackScholesPutPrice(K, T, S_t, vol, r) : d1 = d1f(K, T, S_t, vol, r) d2 = d2f(K, T, S_t, vol, r) putPrice = norm.cdf(-d2) * K * np.exp(-r * T) - norm.cdf(-d1) * S_t return putPrice //定义看涨-看跌期权平价测试公式 def callPutParity(K, T, S_t, r) : return S_t - np.exp(-r * T) * K //对给定变量进行测试 K = 100.0 S_t = 110.0 vol = 0.1 r = 0.03 T = 0.5 call = blackScholesCallPrice(K, T, S_t, vol, r) put = blackScholesPutPrice(K, T, S_t, vol, r) callPutParity_ = callPutParity(K, T, S_t, r) print(\"The call option price is: {0}\".format(call)) print(\"The put option price is: {0}\".format(put)) print(\"Call price - put price is: {0}\".format(call - put)) print(\"The Call-Put-Parity is: {0}\".format(callPutParity_))   致谢：\n妈咪叔LaTeX助力 在线LaTeX\n参考:\nStochastic Calculus for Finance II - Continuous-Time Models\nC++ for Financial Mathematics\n","description":"","tags":["Finance"],"title":"Black-Scholes-Merton Model","uri":"/posts/black-scholes-model/"}]
